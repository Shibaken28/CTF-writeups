<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>shiba&#x27;s writeups</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
</script>


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded "><a href="python/index.html"><strong aria-hidden="true">2.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="python/trap.html"><strong aria-hidden="true">2.1.</strong> Pythonの罠</a></li></ol></li><li class="chapter-item expanded "><a href="2022/index.html"><strong aria-hidden="true">3.</strong> 2022</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022/10/index.html"><strong aria-hidden="true">3.1.</strong> 10月</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2022/10/together.html"><strong aria-hidden="true">3.1.1.</strong> CakeCTF2021 together as one</a></li><li class="chapter-item expanded "><a href="2022/10/discrete.html"><strong aria-hidden="true">3.1.2.</strong> CakeCTF2021 discrete_log</a></li><li class="chapter-item expanded "><a href="2022/10/seq.html"><strong aria-hidden="true">3.1.3.</strong> picoCTF2022 Sequences</a></li><li class="chapter-item expanded "><a href="2022/10/pascal.html"><strong aria-hidden="true">3.1.4.</strong> K3RN3LCTF Pascal RSA</a></li><li class="chapter-item expanded "><a href="2022/10/frozen.html"><strong aria-hidden="true">3.1.5.</strong> CakeCTF2022 frozen cake</a></li><li class="chapter-item expanded "><a href="2022/10/new.html"><strong aria-hidden="true">3.1.6.</strong> CakeCTF2022 brand new crypto</a></li><li class="chapter-item expanded "><a href="2022/10/sweet.html"><strong aria-hidden="true">3.1.7.</strong> waniCTF2021 sweet curve</a></li><li class="chapter-item expanded "><a href="2022/10/cipher.html"><strong aria-hidden="true">3.1.8.</strong> InterKosenCTF2020 ciphertexts</a></li><li class="chapter-item expanded "><a href="2022/10/hugee.html"><strong aria-hidden="true">3.1.9.</strong> CrewCTF2022 The HUGE e</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">shiba&#x27;s writeups</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about"><a class="header" href="#about">About</a></h1>
<h2 id="関連リンク"><a class="header" href="#関連リンク">関連リンク</a></h2>
<ul>
<li><a href="https://shibaken28.github.io/my-library-for-competitive-programming/">shiba's Library</a>
<ul>
<li>競プロ用のライブラリをまとめています．CTFでもたまに競プロの力を使うことがあるので参考になるかも．</li>
</ul>
</li>
</ul>
<h1 id="python"><a class="header" href="#python">Python</a></h1>
<h1 id="pythonの罠"><a class="header" href="#pythonの罠">Pythonの罠</a></h1>
<h2 id="listのコピー"><a class="header" href="#listのコピー"><code>list</code>のコピー</a></h2>
<pre><code class="language-python">a = [1,2,3]
b = a
b[0] = 0
print(a)
</code></pre>
<pre><code class="language-python">[0,2,3]
</code></pre>
<p>なんと，<code>b</code>の代入元である<code>a</code>も変わってしまった．</p>
<p>これを回避するために，<code>a</code>の<code>copy</code>を作る必要がある．</p>
<pre><code class="language-python">a = [1,2,3]
b = a.copy()
b[0] = 0
print(a)
</code></pre>
<pre><code class="language-python">[1,2,3]
</code></pre>
<h2 id="割り算の演算子"><a class="header" href="#割り算の演算子">割り算の演算子</a></h2>
<pre><code class="language-python">a = 5
b = 2
print(a/b)
print(a//b)
</code></pre>
<pre><code class="language-python">2.5
2
</code></pre>
<p><code>/</code>は小数点以下を含む割り算を行う．<code>//</code>は小数点以下を切り捨てた割り算を行う．
<code>/</code>を大きな整数で使おうとすると正しい結果が得られない．</p>
<p>次のプログラムでは，$9999\cdots9999$を$3$で割った値，すなわち$3333\cdots3333$を求めたい．</p>
<pre><code class="language-python">a = 999999999999999999999999999999999999999999999999999999999999999999999999999999999999
b = 3
print(a/b)
print('{:.1000g}'.format(a/b)) #eを使わない表示にする．
print(a//b)
</code></pre>
<pre><code class="language-python">3.333333333333333e+83
333333333333333316642274409837779174589735593005847147516488057690807469867494539264
333333333333333333333333333333333333333333333333333333333333333333333333333333333333
</code></pre>
<p>演算子<code>/</code>を使った場合，でたらめな値が得られたことがわかる．
<code>//</code>を使うと，正しい値が得られる．</p>
<h2 id="小数を扱う関数"><a class="header" href="#小数を扱う関数">小数を扱う関数</a></h2>
<p><code>sqrt</code>関数，<code>pow</code>関数などは小数で計算をする．</p>
<pre><code class="language-python">a = 10
b = pow(a,100)
print('{:.10000g}'.format(b))

x = 10000000000000000000000000000000000
a = x*x
b = sqrt(a)
print('{:.10000g}'.format(b))
</code></pre>
<pre><code class="language-python">10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815104
9999999999999999455752309870428160
</code></pre>
<p>わけのわからない値が得られる．
基本的に<strong>標準ライブラリの関数は信用してはいけない</strong>．PyCryptodome，sagemath，NumPyなどのライブラリを使うか，自分で実装する必要がある．</p>
<h2 id="再帰関数の深さ"><a class="header" href="#再帰関数の深さ">再帰関数の深さ</a></h2>
<pre><code class="language-python">def f(n):
    if n==0:
        return 0
    return f(n-1)+1
print(f(100000))
</code></pre>
<pre><code class="language-python">RecursionError: maximum recursion depth exceeded in comparison
</code></pre>
<p>再帰関数の深さ(recursion depth)の最大値は，デフォルトでは$1000$である．
これを変更するには，<code>sys</code>モジュールを使う．</p>
<pre><code class="language-python">import sys
sys.setrecursionlimit(1000000)
</code></pre>
<h1 id="2022"><a class="header" href="#2022">2022</a></h1>
<h1 id="2022-1"><a class="header" href="#2022-1">2022</a></h1>
<h1 id="cakectf2021-together-as-one"><a class="header" href="#cakectf2021-together-as-one">CakeCTF2021 together as one</a></h1>
<h2 id="問題概要"><a class="header" href="#問題概要">問題概要</a></h2>
<p><a href="https://github.com/theoremoon/cakectf-2021-public/tree/master/crypto/together_as_one/distfiles">問題リンクファイル</a></p>
<p>素数$p,q,r$があり，$e\equiv65537$，フラグを$m$とし，次の値が与えられる．
$$
n \equiv pqr \\
c \equiv m^e \\
x \equiv (p+q)^r \mod n \\
y \equiv (p+qr)^r \mod n
$$</p>
<h2 id="解法"><a class="header" href="#解法">解法</a></h2>
<p>二項定理により，$x$の値について次の計算ができる．
$n=pqr$であり，$0&lt;x&lt;r$のとき${}_r\textrm{C}_x$が$r$の倍数であることを使っている．
$$
\begin{align}
x &amp;\equiv (p+q)^r \mod n \\
&amp;\equiv {}_r\textrm{C}_0 p^rq^0 + {}_r\textrm{C}_1 p^{r-1}q^1 + {}_r \textrm{C}_2 p^{r-2}q^2 +   \cdots + {}_r\textrm{C}_{r-1} p^1q^{r-1} + {}_r\textrm{C}_{r} p^0q^{r-1} \mod n \\
&amp;\equiv p^r + q^r \mod n
\end{align}
$$
$y$も同様に，展開をして$n$の倍数になる項を削除する．
$$
\begin{align}
y &amp;\equiv (p+qr)^r \mod n \\
&amp;\equiv p^r + q^rr^r \mod n
\end{align}
$$
法$q$の世界で考える．すると，
$$
\begin{align}
x &amp;\equiv p^r \mod q\\
y &amp;\equiv p^r \mod q
\end{align}
$$
よって，整数$k$を用いると次が成り立つ
$$
\begin{align}
x &amp;\equiv y \mod q\\
x &amp;\equiv y + kq \\
x - y &amp;\equiv kq
\end{align}
$$</p>
<p>$x-y$は$q$の倍数であり，$n$も素因数$q$を持っているため，$q\equiv\textrm{GCD}(x-y,n)$である．</p>
<p>次に，$x$と$y$を法$r$で考える．フェルマーの小定理により，$p^r \mod r\equiv p$が成り立つ(他の変数も同様)．</p>
<p>$$
\begin{align}
x \equiv p + q \mod r\\
y \equiv p \mod r
\end{align}
$$
$q$が邪魔だが既知であるため，$r$について合同な式ができる．
$$
\begin{align}
x - q \equiv y \mod r\\
\end{align}
$$
よって，$r\equiv\textrm{GCD}(x-q-y,n/q)$である．</p>
<pre><code class="language-python">from Crypto.Util.number import long_to_bytes,inverse

def GCD(a,b):
    if a%b==0:
        return b
    return GCD(b,a%b)

def LCM(a,b):
    return a//GCD(a,b)*b


n = # 長いので省略
c = 
x = 
y = 
e = 0x10001

q = GCD((x-y)%n,n)
r = GCD((x-y-q)%n,n)//q
p = n//r//q

print(f'{p = :#}')
print(f'{q = :#}')
print(f'{r = :#}')
assert p*q*r == n

phi = (p-1)*(q-1)*(r-1)
d = pow(e,-1,phi)
m = pow(c,d,n)
print(long_to_bytes(m))
</code></pre>
<pre><code class="language-none">CakeCTF{This_chall_is_inspired_by_this_music__Check_out!__https://www.youtube.com/watch?v=vLadkYLi8YE_cf49dcb6a31f}
</code></pre>
<h2 id="コメント"><a class="header" href="#コメント">コメント</a></h2>
<p>$q$を見つけた後がわかりませんでした．
こういう式変形して最大公約数とって$p,q$あぶり出すタイプの問題，法を$p$とか$q$して合同な数を見つけようとすると見えやすくなるのかもしれない．</p>
<h1 id="cakectf2021-discrete_log"><a class="header" href="#cakectf2021-discrete_log">CakeCTF2021 discrete_log</a></h1>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p><a href="https://github.com/theoremoon/cakectf-2021-public/tree/master/crypto/discrete-log/distfiles">問題リンク</a></p>
<p>フラグの文字列の$i$文字目の文字コードを$m_i$として
$$
c_i \equiv g^{rm_i} \mod p
$$
の各$c_i$が与えられる．なお，素数$p$と正の整数$g$は与えられている．正の整数$r$は与えられない．</p>
<h2 id="解法-1"><a class="header" href="#解法-1">解法</a></h2>
<p>$g^r$の値がわかれば，$m_i$を全探索(多くて256通り)すればいい．
フラグ形式より，$m_0$が<code>ord(&quot;C&quot;)</code>であることがわかるので，$d\equiv m_0^{-1}\mod \phi(p)$として
$(g^{rm_0})^d \equiv g^r \mod p$と計算することで$g^r$が求める．</p>
<pre><code class="language-python">from Crypto.Util.number import *

def GCD(a,b):
    if a%b==0:
        return b
    return GCD(b,a%b)

def LCM(a,b):
    return a//GCD(a,b)*b

def extGCD(a, b):
    if b:
        d, y, x = extGCD(b, a % b)
        y -= (a // b)*x
        return d, x, y
    return a, 1, 0

p = # 長いので省略
q = 
cs = 

d = inverse(ord(&quot;C&quot;),p-1)
gr = pow(cs[0],d,p)
flag = &quot;&quot;
for c in cs:
    for i in range(1&lt;&lt;8):
        if c==pow(gr,i,p):
            flag += chr(i)
print(flag)
</code></pre>
<pre><code class="language-none">CakeCTF{ba37a0f409ef3ec23a6cffbc474a1cef}
</code></pre>
<h2 id="コメント-1"><a class="header" href="#コメント-1">コメント</a></h2>
<p>1文字ずつ暗号化するのは危険</p>
<h1 id="picoctf2022-sequences"><a class="header" href="#picoctf2022-sequences">picoCTF2022 Sequences</a></h1>
<h2 id="概要-1"><a class="header" href="#概要-1">概要</a></h2>
<p>$$
\begin{align}
a_0 &amp;= 1 \\
a_1 &amp;= 2 \\
a_2 &amp;= 3 \\
a_3 &amp;= 4 \\
a_i &amp;= 21a_{i-1} + 301a_{i-2} - 9549_{i-3} + 55692 a_{i-4} \quad (i&gt;4)
\end{align}
$$
で定義される数列で，$a_{20000000}$を$10^{10000}$で割った余りを求める．</p>
<h2 id="解法-2"><a class="header" href="#解法-2">解法</a></h2>
<p>数列は，$4$項間の線形漸化式である．線形漸化式の$n$項目は高速に求められる(<a href="https://shibaken28.github.io/my-library-for-competitive-programming/famous/fibo.html">参考</a>)．
次のように行列で表し，ダブリングによって累乗を高速に計算する．
$$
\begin{pmatrix}
21 &amp; 301 &amp; -9549 &amp; 55692 \\
1 &amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;0\\
\end{pmatrix}
^{n-3}
\begin{pmatrix}
a_3\\
a_2\\
a_1\\
a_0
\end{pmatrix}
=
\begin{pmatrix}
a_n\\
a_{n-1}\\
a_{n-2}\\
a_{n-3}
\end{pmatrix}
$$</p>
<pre><code class="language-python">import math
import hashlib
import sys
from tqdm import tqdm
import functools

ITERS = int(2e7)
VERIF_KEY = &quot;96cc5f3b460732b442814fd33cf8537c&quot;
ENCRYPTED_FLAG = bytes.fromhex(&quot;42cbbce1487b443de1acf4834baed794f4bbd0dfe08b5f3b248ef7c32b&quot;)

def mat_mul(a, b) :
    I, J, K = len(a), len(b[0]), len(b)
    c = [[0] * J for _ in range(I)]
    for i in range(I) :
        for j in range(J) :
            for k in range(K) :
                c[i][j] += a[i][k] * b[k][j]
            c[i][j] %= 10**10000
    return c


def mat_pow(x, n):
    y = [[0] * len(x) for _ in range(len(x))]

    for i in range(len(x)):
        y[i][i] = 1

    while n &gt; 0:
        if n &amp; 1:
            y = mat_mul(x, y)
        x = mat_mul(x, x)
        n &gt;&gt;= 1

    return y


d0 = 0
ret = [[4], [3], [2],[1]]
mat = [[21,301,-9549,55692], [1, 0, 0, 0], [0, 1, 0, 0],[0,0,1,0]]
#ret = mat_mul(mat_pow(mat, ITERS), ret)
#ret = [[1],[1]]
#mat = [[1,1], [1,0]]
ret = mat_mul(mat_pow(mat, ITRES), ret)
print(ret)


# Decrypt the flag
def decrypt_flag(sol):
    sol = sol % (10**10000)
    sol = str(sol)
    sol_md5 = hashlib.md5(sol.encode()).hexdigest()

    if sol_md5 != VERIF_KEY:
        print(&quot;Incorrect solution&quot;)
        sys.exit(1)

    key = hashlib.sha256(sol.encode()).digest()
    flag = bytearray([char ^ key[i] for i, char in enumerate(ENCRYPTED_FLAG)]).decode()

    print(flag)

if __name__ == &quot;__main__&quot;:
    sol = A
    decrypt_flag(sol)
</code></pre>
<h2 id="コメント-2"><a class="header" href="#コメント-2">コメント</a></h2>
<p>競プロだと基本ですね</p>
<h1 id="k3rn3lctf-pascal-rsa"><a class="header" href="#k3rn3lctf-pascal-rsa">K3RN3LCTF Pascal RSA</a></h1>
<h2 id="問題概要-1"><a class="header" href="#問題概要-1">問題概要</a></h2>
<p>次のPythonファイルと出力が与えら得れる．</p>
<pre><code class="language-python">triangle =[[1]]
flag = open('flag.txt','rb').read()

from Crypto.Util.number import getPrime,bytes_to_long
from math import gcd
p = getPrime(20)
while len(triangle[-1]) &lt;= p:
    r = [1]
    for i in range(len(triangle[-1]) - 1):
        r.append(triangle[-1][i] + triangle[-1][i+1])
    r.append(1)
    triangle.append(r)
code = ''
for x in triangle[-1]:
    code+=str(x%2)
d = int(code,2)
while True:
    P = getPrime(512)
    Q = getPrime(512)
    if gcd(d, (P-1)*(Q-1)) == 1:
        N = P*Q
        e = pow(d,-1,(P-1)*(Q-1))
        break
enc = pow(bytes_to_long(flag), e, N)
file = open('challenge.txt','w')
file.write(f'p = {p}\nenc = {enc}\nN = {N}')
</code></pre>
<pre><code class="language-python">p = 751921
enc = 9820620269072860401665805101881284961421302475382405373888746780467409082575009633494008131637326951607592072546997831382261451919226781535697132306297667495663005072695351430953630099751335020192098397722937812151774786232707555386479774460529133941848677746581256792960571286418291329780280128419358700449
N = 84317137476812805534382776304205215410373527909056058618583365618383741423290821410270929574317899945862949829480082811084554009265439540307568537940249227388935154641779863441301292378975855625325375299980291629608995049742243591901547177853086110999523167557589597375590016312480342995048934488540440868447 
</code></pre>
<h2 id="解法-3"><a class="header" href="#解法-3">解法</a></h2>
<p>問題名がヒントになっていて，$p=751922$段(便宜上，$1$が一つだけの三角形を$0$段と呼ぶことにする)のパスカルの三角形を作り，最下段の偶奇によって$d$を作っている．この$d$を求める問題．
問題ファイルにパスカルの三角形を求めるプログラムがついているが，$p=75192$段のパスカル三角形を作るには時間計算量$O(p^2)$がかかり，非常に時間がかかる．途中経過をすっ飛ばして，最下段の偶奇のみを求める何らかの方法を見つけなければならない．</p>
<p>パスカルの三角形というのは，次のようなものである．
$$
\begin{array}{c}
1 \\
1\ 1\\
1\ 2\ 1\\
1\ 3\ 3\ 1\\
1\ 4\ 6\ 4\ 1\\
1\ 5\ 10\ 10\ 5\ 1\\
\vdots \qquad \vdots \qquad \vdots
\end{array}
$$
これは，二項係数を並べたものと見ることができる．
なぜこれが成り立つかは，三角形の上の頂点からその場所までの経路の数を考えるとわかりやすい(ここではあまり説明しない)．
$$
\begin{array}{c}
{}_0\textrm{C}_0 \\
{}_1\textrm{C}_0\ {}_1\textrm{C}_1\\
{}_2\textrm{C}_0\ {}_2\textrm{C}_1\ {}_2\textrm{C}_2\\
{}_3\textrm{C}_0\ {}_3\textrm{C}_1\ {}_3\textrm{C}_2\ {}_3\textrm{C}_3\\
{}_4\textrm{C}_0\ {}_4\textrm{C}_1\ {}_4\textrm{C}_2\ {}_4\textrm{C}_3\ {}_4\textrm{C}_4\\
\vdots \qquad \vdots \qquad \vdots
\end{array}
$$
$p$段のパスカルの三角形の最下段は，${}_p\textrm{C}_i(0\leq i\leq p)$が並んでいる．</p>
<p>ここで，ルーカスの定理を使う．</p>
<p>$$
{}_m\textrm{C}_n = \prod_{i=0}^{k} {}_{m_i}\textrm{C}_{n_i} \pmod p \\
$$
ただし，$m_k m_{k-1} m_{k-2} \cdots m_1 m_0$は $m$の$p$進数表示，$n_k n_{k-1} n_{k-2} \cdots n_1 n_0$は $n$の$p$進数表示である．
特に，$\pmod 2$の世界は次の$4$パターンしか出てこない．
$$
{}_1\textrm{C}_0 = 1 \\
{}_1\textrm{C}_1 = 1 \\
{}_0\textrm{C}_0 = 1 \\
{}_0\textrm{C}_1 = 0
$$
よって，ルーカスの定理を使うときに${}_0\textrm{C}_1$($m_i=0$かつ$n_i=1$となる$i$)が1つも出てこなかったら，計算結果は$1 \pmod 2$，すなわち奇数となる．これは，<code>m&amp;n == n</code>が真であることと同値である．</p>
<p>これで，${}_p\textrm{C}_i(0\leq i\leq p)$の偶奇が各$i$について$O(1)$で計算できる．</p>
<pre><code class="language-python">p = 751921
enc = 9820620269072860401665805101881284961421302475382405373888746780467409082575009633494008131637326951607592072546997831382261451919226781535697132306297667495663005072695351430953630099751335020192098397722937812151774786232707555386479774460529133941848677746581256792960571286418291329780280128419358700449
N = 84317137476812805534382776304205215410373527909056058618583365618383741423290821410270929574317899945862949829480082811084554009265439540307568537940249227388935154641779863441301292378975855625325375299980291629608995049742243591901547177853086110999523167557589597375590016312480342995048934488540440868447


def is_nCk_odd( n,k):
    return n&amp;k == k

code=''
for i in range(0,p+1):
    ch=is_nCk_odd(p,i)
    if ch:
        code+='1'
    else:
        code+='0'

d=int(code,2)

print(hex(pow(enc,d,N)))
</code></pre>
<h2 id="コメント-3"><a class="header" href="#コメント-3">コメント</a></h2>
<p>めっちゃ数論</p>
<h1 id="cakectf2022-frozen-cake"><a class="header" href="#cakectf2022-frozen-cake">CakeCTF2022 frozen cake</a></h1>
<h2 id="問題"><a class="header" href="#問題">問題</a></h2>
<p><a href="https://github.com/theoremoon/cakectf2022-public/tree/master/crypto/frozen_cake/distfiles">問題ファイル</a>
素数$p,q$と平文$m$，$n=pq$から次の$a,b,c$の値が与えられる．$n$の値も与えられる．
$$
\begin{align}
a &amp;\equiv m^p \mod n \\
b &amp;\equiv m^q \mod n \\
c &amp;\equiv m^n \mod n
\end{align}
$$</p>
<h2 id="解法-4"><a class="header" href="#解法-4">解法</a></h2>
<p>$p$と$q$は$\phi(n)$と互いに素ではないため，$a,b$から$m$を復元するのは難しそう．
$c$を変形してみる．</p>
<p>$$
n = (p-1)(q-1) + p+q-1 = \phi(n) + p+q-1 \\
c \equiv m^n \equiv m^{\phi(n) +p+q-1} \equiv m^{p+q-1} \equiv m^p m^q m^{-1}\pmod n
$$</p>
<p>ここで，$m^p,m^q\pmod n$の値はわかっているので，
$$
c a^{-1} b^{-1} \equiv m^{-1} \pmod n
$$
これで$m^{-1}\mod n$が求まり，これの逆数がフラグである．</p>
<pre><code class="language-python">from Crypto.Util.number import inverse , long_to_bytes

n = 101205131618457490641888226172378900782027938652382007193297646066245321085334424928920128567827889452079884571045344711457176257019858157287424646000972526730522884040459357134430948940886663606586037466289300864147185085616790054121654786459639161527509024925015109654917697542322418538800304501255357308131
a = 38686943509950033726712042913718602015746270494794620817845630744834821038141855935687477445507431250618882887343417719366326751444481151632966047740583539454488232216388308299503129892656814962238386222995387787074530151173515835774172341113153924268653274210010830431617266231895651198976989796620254642528
b = 83977895709438322981595417453453058400465353471362634652936475655371158094363869813512319678334779139681172477729044378942906546785697439730712057649619691929500952253818768414839548038664187232924265128952392200845425064991075296143440829148415481807496095010301335416711112897000382336725454278461965303477
c = 21459707600930866066419234194792759634183685313775248277484460333960658047171300820279668556014320938220170794027117386852057041210320434076253459389230704653466300429747719579911728990434338588576613885658479123772761552010662234507298817973164062457755456249314287213795660922615911433075228241429771610549

ainv = inverse(a,n)
binv = inverse(b,n)
minv = (c * ainv * binv)%n
print(long_to_bytes(inverse(minv,n)))

</code></pre>
<pre><code>CakeCTF{oh_you_got_a_tepid_cake_sorry}
</code></pre>
<h2 id="コメント-4"><a class="header" href="#コメント-4">コメント</a></h2>
<p>CakeCTF 2022 開催記より引用(<a href="https://furutsuki.hatenablog.com/entry/2022/09/05/000733#frozen-cake">リンク</a>)．</p>
<blockquote>
<p>warmupでRSAの乗法準同型性に関する知識とフェルマーの小定理を要求していてなかなかハードですね。とはいえCTFの暗号分野では基礎となるような数学の知識ですので、CTFの問題としてはこのくらいは出題したいところです。これが解けたらある程度のCryptoに関する実力がありますと言って良いんじゃないかと思います。</p>
</blockquote>
<p>ある程度のCryptoに関する実力があるそうです．暗号er名乗っていいですか！</p>
<h1 id="cakectf2022-brand-new-crypto"><a class="header" href="#cakectf2022-brand-new-crypto">CakeCTF2022 brand new crypto</a></h1>
<h2 id="問題-1"><a class="header" href="#問題-1">問題</a></h2>
<p><a href="https://github.com/theoremoon/cakectf2022-public/tree/master/crypto/brand_new_crypto/distfiles">問題リンク</a></p>
<p>素数$p,q$があり，$n=pq$．$\phi=(p-1)(q-1)$として$0$以上$\phi$以下の整数$a,s$があり，</p>
<p>$$
\begin{align}
\phi &amp;= (p-1)(q-1) \\
b &amp;= \phi + 1 -a \\
t &amp;= -sa b^{-1} \pmod \phi
\end{align}
$$</p>
<p>$b$と$\phi$は互いに素であることが保証される．
$0$以上$n$以下の整数$r$を使って次のように暗号化される
$$
c_1 \equiv mr^s \pmod n\\
c_2 \equiv mr^t \pmod n
$$
復元は次のようにできる
$$
m = c_1 ^a c_2^b \pmod n
$$</p>
<p>その他色々な条件があるが，この暗号が破綻しないために例外を考えなくていいということなんだろう．</p>
<p>そして，各フラグの$i$文字目の文字コード$m_i$についてこの暗号化をした値$c_1,c_2$が与えられる．また，全体で$a,b,s,t,p,q$の値は固定．$r$だけランダム．
与えられる値は，各暗号化された値と$s,t,n$．</p>
<h2 id="考えたこと"><a class="header" href="#考えたこと">考えたこと</a></h2>
<p>なんかよくわからないのでまず復元で何が起こっているかを見ておく．
確かに，
$$
m\equiv  c_1 ^a c_2 ^b \equiv (mr^s)^a (mr^t)^b \equiv m^a r^{sa} m^b r^{-sab^{-1}b} \equiv m^{ab}r^{sa-sa} \equiv m^{ab} \equiv m^{\phi+1} \equiv m \pmod n
$$
と成り立っている．
なんとなく，$t$が$a,b$にから計算されているので，これをうまく使うんじゃないかと思う．
あと，$m_i$がせいぜい256通りなので，それっぽい値がわかれば全探索が可能．</p>
<p>4時間後，次の方法が思いついた．</p>
<p>$$
(mr^s)^t (mr^t)^{-s} \equiv m^{t-s} r^{st-st} \equiv m^{t-s} \pmod n
$$</p>
<p>これで，$m$を全探索して$m^{t-s}\pmod n$と一致するものを見つければ良い．
$s$と$t$が具体的にどんな方法で出された値であるかを考える必要はなかったのだ．</p>
<pre><code class="language-python">from Crypto.Util.number import inverse , long_to_bytes

s,t,n = 長いので省略
cs = 

flag = &quot;&quot;
for c1,c2 in cs:
    mst = (pow(c1,t,n)*pow(pow(c2,s,n)%n,-1,n))%n
    print(mst)
    for m in range(256):
        if pow(m,t-s,n)==mst:
            print(chr(m))
            flag += chr(m)
print(flag)

</code></pre>
<pre><code class="language-none">CakeCTF{s0_anyway_tak3_car3_0f_0n3_byt3_p1aint3xt}
</code></pre>
<h2 id="コメント-5"><a class="header" href="#コメント-5">コメント</a></h2>
<p>悩んだ割に結構解法がシンプルでした．こういうちょっと複雑になっただけで頭が堅くなってしまう！
$m$が同じで$e$が異なるRSAへの攻撃手法を思い出しました．
同じ数の異なる冪数があるときはこの道の解法を考えると良さそう．</p>
<h1 id="wanictf2021-sweet_curve"><a class="header" href="#wanictf2021-sweet_curve">waniCTF2021 sweet_curve</a></h1>
<h2 id="問題-2"><a class="header" href="#問題-2">問題</a></h2>
<p><a href="https://github.com/wani-hackase/wanictf2021-writeup/tree/main/cry/sweet_curve/file">問題ファイル</a>
．次の有限体$\mathbb{F}_p$の楕円曲線上の点$P,Q$が与えられるので，$P+Q$の$x$を求めよという問題．
$$
y^2 \equiv x^3 - x + 1 \pmod p
$$</p>
<h2 id="解法-5"><a class="header" href="#解法-5">解法</a></h2>
<p>これを解くsagemathのソースコードは次の通り．</p>
<pre><code class="language-python">from Crypto.Util.number import long_to_bytes

# Given:
# - An elliptic curve: y**2 = x**3 - x + 1 (mod p)
# - Two points: P(x_P, y_P) and Q(x_Q, y_Q)

# Find the point P+Q
# The flag is the x value of P+Q
# Don't forget to convert it into a string!
p = 0x89a4e2c7f834f5fbc6f2a314e373e3723de7df6283c5d97cbca509c61e02965b7ef96efce1d827bfdfa7f21d22803558bb549f9ea15dfe9f47d3976648c55feb
x_P = 0x1e1cba0e07c61cf88e9f23b9859093c33c26cf83bcfb6fe24d7559cd0ea86fb2f144ae643ac5edf6f04ef065dc7c2c18d88ae02843592d5e611029fefc0fece
y_P = 0x198420b30a4330f82380326895d0ac06a1859bc49d45cd4b08021b857d23d515163b9151fbaf7ae5f816d485d129d3b1c4630d1fb45c6790af551428a5c85667
x_Q = 0x7e32edfd7befd8df93d7b738d6a1c95e1cfd56b3a6ccc4a62e4e0ae9059b4903e71fccbe07d8d45c762b4a3ed5c9d1a2505043d033e58adb72191259b81bc47d
y_Q = 0x46016c676585feaf048fff9d5cbb45dbd598c6c4c81694e0881bf110b57012f0bac6eaf7376fee015c8cecba1fc92206ca346f7d72ee1d60f820091c85fa76b3

# y^2 + a1 xy + a3 y = x^3 + a2 x^2 + a4 x + a6
# [a4,a6]
E = EllipticCurve(GF(p), [-1,1])
P = E([x_P, y_P])
Q = E([x_Q, y_Q])
x = (P+Q)[0]
print(x)
print(long_to_bytes(int(x)))
</code></pre>
<p>sagemathにおける楕円曲線については<a href="https://doc.sagemath.org/html/ja/tutorial/tour_advanced.html">こちら</a>に載っている．</p>
<h2 id="コメント-6"><a class="header" href="#コメント-6">コメント</a></h2>
<p>僕にとってsagemathのリファレンスはほとんど意味がわかりません．</p>
<h1 id="interkosenctf2020-ciphertexts"><a class="header" href="#interkosenctf2020-ciphertexts">InterKosenCTF2020 ciphertexts</a></h1>
<h2 id="問題-3"><a class="header" href="#問題-3">問題</a></h2>
<p>平文$m$，素数$p,q,r$があって，$n_1=pq$，$n_2=pqr$，素数$e_1$とその次に大きい素数$e_2$を用意．
$$
\begin{align}
c_1 &amp;= m^{e_1} \pmod {pq} \\
c_2 &amp;= m^{e_2} \pmod  {pqr}
\end{align}
$$
$p,q,r$以外は与えられる．</p>
<h2 id="解法-6"><a class="header" href="#解法-6">解法</a></h2>
<pre><code class="language-python">r = n2//n1
d=pow(e1,-1,r-1)
m=pow(c1,d,r)
print(long_to_bytes(m))
</code></pre>
<p>$r$がバレているので$\mod r$の世界で考えれば行けるんじゃないかと思ったがだめだった．
では，$\mod pq$の世界ではどうだろうか．$c_2$を$\pmod {pq}$で考えて，$e_1x+e_2y=1$となるような$x,y$を見つけてくれば良い．
$$
c_1^x c_2^y \equiv (m^{e_1})^x(m^{e_2})^y  \equiv m^{e_1x+e_2y} \equiv m \pmod {pq}
$$</p>
<pre><code class="language-python">x = -74571
y = 74570
print(e1*x+e2*y) # 1
m = (pow(c1,x,n1)*pow(c2,y,n1))%n1
print(long_to_bytes(m))
</code></pre>
<pre><code class="language-python">1
b'KosenCTF{HALDYN_D0M3}'
</code></pre>
<p>出てきた．</p>
<h2 id="コメント-7"><a class="header" href="#コメント-7">コメント</a></h2>
<p>warmup問題として出たらしい．</p>
<h1 id="crewctf2022-the-huge-e"><a class="header" href="#crewctf2022-the-huge-e">CrewCTF2022 The HUGE e</a></h1>
<h2 id="問題-4"><a class="header" href="#問題-4">問題</a></h2>
<pre><code>p = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823
e1 = 219560036291700924162367491740680392841
e2 = 325829142086458078752836113369745585569
e3 = 237262361171684477270779152881433264701
c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613
</code></pre>
<p>のパラメータが与えられる．$c$は，$m$を次の式によって計算された値である．
$$
c \equiv m^{e_1^{e_2^{e_3}}} \pmod p
$$
また，$p$はとてもsmoothである．</p>
<h2 id="解法-7"><a class="header" href="#解法-7">解法</a></h2>
<p>$e=e_1^{e_2^{e_3}}$として$d=e^1\mod \phi(p)$が求まれば良いわけだが，タイトルの通り$e$がとんでもなく大きな数になってしまうため，何か工夫が必要だ．</p>
<p>オイラーの定理(またはフェルマーの小定理)より，$e\equiv e_1^{e_2^{e^3}} \pmod {\phi(p)}$としてしまって良い．これで，$ e_1^{e_2^{e^3}}\pmod {p-1}$の値を求める問題になった．
ここでさらに，$e_1^{e_2^{e^3}}=e_1^{e_4}$とおくと，$e_4 \equiv e_2^{e_3} \pmod {\phi(p-1)}$としてしまって良い．これなら簡単に求められる．$\phi(p-1)$の値だが，$p-1$がsmoothであることを使えば簡単に求められる．</p>
<pre><code class="language-python">def factor(N):
    f = [] # p-1の素因数分解
    i = 2
    N = p-1
    while i*i&lt;=N:
        if N%i==0:
            f.append(i)
            N = N//i
        else:
            i+=1
    f.append(N)
    return f

p = 127557933868274766492781168166651795645253551106939814103375361345423596703884421796150924794852741931334746816404778765897684777811408386179315837751682393250322682273488477810275794941270780027115435485813413822503016999058941190903932883823
e1 = 219560036291700924162367491740680392841
e2 = 325829142086458078752836113369745585569
e3 = 237262361171684477270779152881433264701
c = 962976093858853504877937799237367527464560456536071770645193845048591657714868645727169308285896910567283470660044952959089092802768837038911347652160892917850466319249036343642773207046774240176141525105555149800395040339351956120433647613
phi = p-1
phiphi = 1
fs = factor(phi)
for f in fs:
    phiphi *= f-1
e4 = pow(e2,e3,phiphi)
e = pow(e1,e4,phi)
d = pow(e,-1,phi)
m = pow(c,d,p)
print(long_to_bytes(m))
</code></pre>
<pre><code class="language-none">crew{7hi5_1s_4_5ma11er_numb3r_7han_7h3_Gr4ham_numb3r}
</code></pre>
<h2 id="コメント-8"><a class="header" href="#コメント-8">コメント</a></h2>
<p>フェルマーの小定理やオイラー関数を正しく使えるかを問う問題だった．競プロでも<a href="https://atcoder.jp/contests/abc228/tasks/abc228_e">ABC228-E</a>みたいなフェルマーの小定理をしっかり使う問題が出ています．</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
